[
  {
    "instance_id": "caddyserver__caddy-6448",
    "model_patch": "diff --git a/modules/caddyhttp/reverseproxy/upstreams.go b/modules/caddyhttp/reverseproxy/upstreams.go\nindex 46e45c64652..c8ba930d203 100644\n--- a/modules/caddyhttp/reverseproxy/upstreams.go\n+++ b/modules/caddyhttp/reverseproxy/upstreams.go\n@@ -231,6 +231,19 @@ type IPVersions struct {\n \tIPv6 *bool `json:\"ipv6,omitempty\"`\n }\n \n+func resolveIpVersion(versions *IPVersions) string {\n+\tresolveIpv4 := versions == nil || (versions.IPv4 == nil && versions.IPv6 == nil) || (versions.IPv4 != nil && *versions.IPv4)\n+\tresolveIpv6 := versions == nil || (versions.IPv6 == nil && versions.IPv4 == nil) || (versions.IPv6 != nil && *versions.IPv6)\n+\tswitch {\n+\tcase resolveIpv4 && !resolveIpv6:\n+\t\treturn \"ip4\"\n+\tcase !resolveIpv4 && resolveIpv6:\n+\t\treturn \"ip6\"\n+\tdefault:\n+\t\treturn \"ip\"\n+\t}\n+}\n+\n // AUpstreams provides upstreams from A/AAAA lookups.\n // Results are cached and refreshed at the configured\n // refresh interval.\n@@ -313,9 +326,6 @@ func (au *AUpstreams) Provision(ctx caddy.Context) error {\n func (au AUpstreams) GetUpstreams(r *http.Request) ([]*Upstream, error) {\n \trepl := r.Context().Value(caddy.ReplacerCtxKey).(*caddy.Replacer)\n \n-\tresolveIpv4 := au.Versions == nil || au.Versions.IPv4 == nil || *au.Versions.IPv4\n-\tresolveIpv6 := au.Versions == nil || au.Versions.IPv6 == nil || *au.Versions.IPv6\n-\n \t// Map ipVersion early, so we can use it as part of the cache-key.\n \t// This should be fairly inexpensive and comes and the upside of\n \t// allowing the same dynamic upstream (name + port combination)\n@@ -324,15 +334,7 @@ func (au AUpstreams) GetUpstreams(r *http.Request) ([]*Upstream, error) {\n \t// It also forced a cache-miss if a previously cached dynamic\n \t// upstream changes its ip version, e.g. after a config reload,\n \t// while keeping the cache-invalidation as simple as it currently is.\n-\tvar ipVersion string\n-\tswitch {\n-\tcase resolveIpv4 && !resolveIpv6:\n-\t\tipVersion = \"ip4\"\n-\tcase !resolveIpv4 && resolveIpv6:\n-\t\tipVersion = \"ip6\"\n-\tdefault:\n-\t\tipVersion = \"ip\"\n-\t}\n+\tipVersion := resolveIpVersion(au.Versions)\n \n \tauStr := repl.ReplaceAll(au.String()+ipVersion, \"\")\n \n",
    "model_name_or_path": "fake_model"
  }
]
