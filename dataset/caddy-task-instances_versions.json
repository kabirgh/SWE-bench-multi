[{
  "repo": "caddyserver/caddy",
  "pull_number": 6448,
  "instance_id": "caddyserver__caddy-6448",
  "issue_numbers": ["6442"],
  "base_commit": "9338741ca79a74247ced86bc26e4994138470852",
  "patch": "diff --git a/modules/caddyhttp/reverseproxy/upstreams.go b/modules/caddyhttp/reverseproxy/upstreams.go\nindex 46e45c64652..c8ba930d203 100644\n--- a/modules/caddyhttp/reverseproxy/upstreams.go\n+++ b/modules/caddyhttp/reverseproxy/upstreams.go\n@@ -231,6 +231,19 @@ type IPVersions struct {\n \tIPv6 *bool `json:\"ipv6,omitempty\"`\n }\n \n+func resolveIpVersion(versions *IPVersions) string {\n+\tresolveIpv4 := versions == nil || (versions.IPv4 == nil && versions.IPv6 == nil) || (versions.IPv4 != nil && *versions.IPv4)\n+\tresolveIpv6 := versions == nil || (versions.IPv6 == nil && versions.IPv4 == nil) || (versions.IPv6 != nil && *versions.IPv6)\n+\tswitch {\n+\tcase resolveIpv4 && !resolveIpv6:\n+\t\treturn \"ip4\"\n+\tcase !resolveIpv4 && resolveIpv6:\n+\t\treturn \"ip6\"\n+\tdefault:\n+\t\treturn \"ip\"\n+\t}\n+}\n+\n // AUpstreams provides upstreams from A/AAAA lookups.\n // Results are cached and refreshed at the configured\n // refresh interval.\n@@ -313,9 +326,6 @@ func (au *AUpstreams) Provision(ctx caddy.Context) error {\n func (au AUpstreams) GetUpstreams(r *http.Request) ([]*Upstream, error) {\n \trepl := r.Context().Value(caddy.ReplacerCtxKey).(*caddy.Replacer)\n \n-\tresolveIpv4 := au.Versions == nil || au.Versions.IPv4 == nil || *au.Versions.IPv4\n-\tresolveIpv6 := au.Versions == nil || au.Versions.IPv6 == nil || *au.Versions.IPv6\n-\n \t// Map ipVersion early, so we can use it as part of the cache-key.\n \t// This should be fairly inexpensive and comes and the upside of\n \t// allowing the same dynamic upstream (name + port combination)\n@@ -324,15 +334,7 @@ func (au AUpstreams) GetUpstreams(r *http.Request) ([]*Upstream, error) {\n \t// It also forced a cache-miss if a previously cached dynamic\n \t// upstream changes its ip version, e.g. after a config reload,\n \t// while keeping the cache-invalidation as simple as it currently is.\n-\tvar ipVersion string\n-\tswitch {\n-\tcase resolveIpv4 && !resolveIpv6:\n-\t\tipVersion = \"ip4\"\n-\tcase !resolveIpv4 && resolveIpv6:\n-\t\tipVersion = \"ip6\"\n-\tdefault:\n-\t\tipVersion = \"ip\"\n-\t}\n+\tipVersion := resolveIpVersion(au.Versions)\n \n \tauStr := repl.ReplaceAll(au.String()+ipVersion, \"\")\n \n",
  "test_patch": "diff --git a/modules/caddyhttp/reverseproxy/upstreams_test.go b/modules/caddyhttp/reverseproxy/upstreams_test.go\nnew file mode 100644\nindex 00000000000..48e2d2a6310\n--- /dev/null\n+++ b/modules/caddyhttp/reverseproxy/upstreams_test.go\n@@ -0,0 +1,56 @@\n+package reverseproxy\n+\n+import \"testing\"\n+\n+func TestResolveIpVersion(t *testing.T) {\n+\tfalseBool := false\n+\ttrueBool := true\n+\ttests := []struct {\n+\t\tVersions          *IPVersions\n+\t\texpectedIpVersion string\n+\t}{\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv4: &trueBool},\n+\t\t\texpectedIpVersion: \"ip4\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv4: &falseBool},\n+\t\t\texpectedIpVersion: \"ip\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv4: &trueBool, IPv6: &falseBool},\n+\t\t\texpectedIpVersion: \"ip4\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv6: &trueBool},\n+\t\t\texpectedIpVersion: \"ip6\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv6: &falseBool},\n+\t\t\texpectedIpVersion: \"ip\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv6: &trueBool, IPv4: &falseBool},\n+\t\t\texpectedIpVersion: \"ip6\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{},\n+\t\t\texpectedIpVersion: \"ip\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv4: &trueBool, IPv6: &trueBool},\n+\t\t\texpectedIpVersion: \"ip\",\n+\t\t},\n+\t\t{\n+\t\t\tVersions:          &IPVersions{IPv4: &falseBool, IPv6: &falseBool},\n+\t\t\texpectedIpVersion: \"ip\",\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tipVersion := resolveIpVersion(test.Versions)\n+\t\tif ipVersion != test.expectedIpVersion {\n+\t\t\tt.Errorf(\"resolveIpVersion(): Expected %s got %s\", test.expectedIpVersion, ipVersion)\n+\t\t}\n+\t}\n+\n+}\n",
  "problem_statement": "can't disable IPv4/IPv6 for dynamic reverse proxy from Caddyfile\nAs per the forum discussion at https://caddy.community/t/reverse-proxy-to-dynamic-ipv4-only/24773/3 , I found it's not possible to disable IPv4 or IPv6 in a `reverse_proxy` `dynamic a` block from the Caddyfile.\r\n\r\nIf I use\r\n```\r\n:9000 {\r\n\treverse_proxy {\r\n\t\tdynamic a potoroo 8123 {\r\n\t\t\tversions ipv4\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nthen I get a caddy.json which has `\"versions\":{\"ipv4\":true}}`, but Caddy still uses IPv6 if available. \r\n\r\nIf I explicitly add `\"ipv6\":\"false\"` then it works, but this can't be set from the Caddyfile (that I'm aware of).\n",
  "hints_text": "Good find, thanks. Anyone is welcome to work on this! :)\nIs the expected logic here that when `ipv4` is specified in `versions` , we should automatically set `ipv6` to false or are we adding the ability for the users to set `ipv6`  (or `ipv4` for instance) to false via the caddy file? ",
  "created_at": "2024-07-09T00:20:17Z",
  "version": "6448",
  "FAIL_TO_PASS": "[]",
  "PASS_TO_PASS": "[]"
}]
