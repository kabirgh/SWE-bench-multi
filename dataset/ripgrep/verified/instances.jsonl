{"repo":"burntsushi/ripgrep","pull_number":2576,"instance_id":"burntsushi__ripgrep-2576","issue_numbers":["2574"],"base_commit":"fed4fea217abbc502f2e823465de903c8f2b623d","patch":"diff --git a/CHANGELOG.md b/CHANGELOG.md\nindex 1b4352733..c637aeaea 100644\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -38,6 +38,8 @@ Bug fixes:\n   Fix bug when using inline regex flags with `-e/--regexp`.\n * [BUG #2523](https://github.com/BurntSushi/ripgrep/issues/2523):\n   Make executable searching take `.com` into account on Windows.\n+* [BUG #2574](https://github.com/BurntSushi/ripgrep/issues/2574):\n+  Fix bug in `-w/--word-regexp` that would result in incorrect match offsets.\n \n \n 13.0.0 (2021-06-12)\ndiff --git a/crates/regex/src/word.rs b/crates/regex/src/word.rs\nindex af4480abb..52fb61cef 100644\n--- a/crates/regex/src/word.rs\n+++ b/crates/regex/src/word.rs\n@@ -128,6 +128,9 @@ impl WordMatcher {\n         // The reason why we cannot handle the ^/$ cases here is because we\n         // can't assume anything about the original pattern. (Try commenting\n         // out the checks for ^/$ below and run the tests to see examples.)\n+        //\n+        // NOTE(2023-07-31): After fixing #2574, this logic honestly still\n+        // doesn't seem correct. Regex composition is hard.\n         let input = Input::new(haystack).span(at..haystack.len());\n         let mut cand = match self.regex.find(input) {\n             None => return Ok(None),\n@@ -136,8 +139,17 @@ impl WordMatcher {\n         if cand.start() == 0 || cand.end() == haystack.len() {\n             return Err(());\n         }\n-        let (_, slen) = bstr::decode_utf8(&haystack[cand]);\n-        let (_, elen) = bstr::decode_last_utf8(&haystack[cand]);\n+        // We decode the chars on either side of the match. If either char is\n+        // a word character, then that means the ^/$ matched and not \\W. In\n+        // that case, we defer to the slower engine.\n+        let (ch, slen) = bstr::decode_utf8(&haystack[cand]);\n+        if ch.map_or(true, regex_syntax::is_word_character) {\n+            return Err(());\n+        }\n+        let (ch, elen) = bstr::decode_last_utf8(&haystack[cand]);\n+        if ch.map_or(true, regex_syntax::is_word_character) {\n+            return Err(());\n+        }\n         let new_start = cand.start() + slen;\n         let new_end = cand.end() - elen;\n         // This occurs the original regex can match the empty string. In this\n","test_patch":"diff --git a/tests/regression.rs b/tests/regression.rs\nindex b90768032..5ef741cf6 100644\n--- a/tests/regression.rs\n+++ b/tests/regression.rs\n@@ -1173,3 +1173,18 @@ rgtest!(r2480, |dir: Dir, mut cmd: TestCommand| {\n     cmd.args(&[\"--only-matching\", \"-e\", \"(?i)notfoo\", \"-e\", \"bar\", \"file\"]);\n     cmd.assert_err();\n });\n+\n+// See: https://github.com/BurntSushi/ripgrep/issues/2574\n+rgtest!(r2574, |dir: Dir, mut cmd: TestCommand| {\n+    dir.create(\"haystack\", \"some.domain.com\\nsome.domain.com/x\\n\");\n+    let got = cmd\n+        .args(&[\n+            \"--no-filename\",\n+            \"--no-unicode\",\n+            \"-w\",\n+            \"-o\",\n+            r\"(\\w+\\.)*domain\\.(\\w+)\",\n+        ])\n+        .stdout();\n+    eqnice!(\"some.domain.com\\nsome.domain.com\\n\", got);\n+});\n","problem_statement":"Incomplete matches when using the `--word-regexp` flag\n#### What version of ripgrep are you using?\r\nripgrep 13.0.0\r\n-SIMD -AVX (compiled)\r\n\r\n#### How did you install ripgrep?\r\n`wget https://github.com/BurntSushi/ripgrep/releases/download/13.0.0/ripgrep-13.0.0-x86_64-unknown-linux-musl.tar.gz`\r\n\r\n#### What operating system are you using ripgrep on?\r\nMac and Linux\r\n\r\n#### Describe your bug.\r\nAccording to the manual: \r\n```\r\n-w, --word-regexp\r\n            Only show matches surrounded by word boundaries. This is roughly equivalent to\r\n            putting \\b before and after all of the search patterns.\r\n```\r\n\r\nI'm using this text as a sample file:\r\n```\r\nsome.domain.com\r\nsome.domain.com/x\r\nsome.domain.com\r\n```\r\n\r\nAnd here is some very naive regex that searches for \"domains\" (not really, but it is enough to show the problem):\r\n`\"([\\w]+[.])*domain[.](\\w)+`\r\n\r\nRunning this regex with the `-w` flag (`rg -w \"([\\w]+[.])*domain[.](\\w)+\"`) matches the first and third strings properly (`some.domain.com`), but for the second one **starts capturing from the second char onwards**, meaning it matches `ome.domain.com`.\r\n\r\nIf I change the execution, remove the `-w` flag and wrap the regex with `\\b` (`rg \"\\b([\\w]+[.])*domain[.](\\w)+\\b\"`), then all lines are matched properly (`some.domain.com` is matched).\r\n\r\n#### What are the steps to reproduce the behavior?\r\nExplained above.\r\n\r\n#### What is the actual behavior?\r\nhttps://gist.github.com/ilia-cy/396f43f57057e42723d4a3dc87d4e994\r\nThe matches aren't shown here because they are highlighted in the terminal, so i'm adding a screenshot:\r\n\r\n<img width=\"270\" alt=\"image\" src=\"https://github.com/BurntSushi/ripgrep/assets/60312091/04a73a38-4829-4c16-8497-9f53a5219ac5\">\r\n\r\n\r\n#### What is the expected behavior?\r\nI would expect that the flag usage would work similarly as wrapping the pattern with `\\b` (as the manual indicates), so that all the `some.domain.com` instances will be matched.\r\n\n","hints_text":"","created_at":"2023-07-31T12:06:17Z","url":"https://github.com/BurntSushi/ripgrep/pull/2576","version":"2576","related_issues":[{"number":2574,"title":"Incomplete matches when using the `--word-regexp` flag","body":"#### What version of ripgrep are you using?\r\nripgrep 13.0.0\r\n-SIMD -AVX (compiled)\r\n\r\n#### How did you install ripgrep?\r\n`wget https://github.com/BurntSushi/ripgrep/releases/download/13.0.0/ripgrep-13.0.0-x86_64-unknown-linux-musl.tar.gz`\r\n\r\n#### What operating system are you using ripgrep on?\r\nMac and Linux\r\n\r\n#### Describe your bug.\r\nAccording to the manual: \r\n```\r\n-w, --word-regexp\r\n            Only show matches surrounded by word boundaries. This is roughly equivalent to\r\n            putting \\b before and after all of the search patterns.\r\n```\r\n\r\nI'm using this text as a sample file:\r\n```\r\nsome.domain.com\r\nsome.domain.com/x\r\nsome.domain.com\r\n```\r\n\r\nAnd here is some very naive regex that searches for \"domains\" (not really, but it is enough to show the problem):\r\n`\"([\\w]+[.])*domain[.](\\w)+`\r\n\r\nRunning this regex with the `-w` flag (`rg -w \"([\\w]+[.])*domain[.](\\w)+\"`) matches the first and third strings properly (`some.domain.com`), but for the second one **starts capturing from the second char onwards**, meaning it matches `ome.domain.com`.\r\n\r\nIf I change the execution, remove the `-w` flag and wrap the regex with `\\b` (`rg \"\\b([\\w]+[.])*domain[.](\\w)+\\b\"`), then all lines are matched properly (`some.domain.com` is matched).\r\n\r\n#### What are the steps to reproduce the behavior?\r\nExplained above.\r\n\r\n#### What is the actual behavior?\r\nhttps://gist.github.com/ilia-cy/396f43f57057e42723d4a3dc87d4e994\r\nThe matches aren't shown here because they are highlighted in the terminal, so i'm adding a screenshot:\r\n\r\n<img width=\"270\" alt=\"image\" src=\"https://github.com/BurntSushi/ripgrep/assets/60312091/04a73a38-4829-4c16-8497-9f53a5219ac5\">\r\n\r\n\r\n#### What is the expected behavior?\r\nI would expect that the flag usage would work similarly as wrapping the pattern with `\\b` (as the manual indicates), so that all the `some.domain.com` instances will be matched.\r\n","url":"https://github.com/BurntSushi/ripgrep/issues/2574","labels":["bug"]}],"body":"It turns out our fast path for -w/--word-regexp wasn't quite correct in some cases. Namely, we use `(?m:^|\\W)(<original-regex>)(?m:\\W|$)` as the implementation of -w/--word-regexp since `\\b(<original-regex>)\\b` has some unintuitive results in certain cases, specifically when <original-regex> matches non-word characters at match boundaries.\r\n\r\nThe problem is that using this formulation means that you need to extract the capture group around <original-regex> to find the \"real\" match, since the surrounding (^|\\W) and (\\W|$) aren't part of the match. This is fine, but the capture group engine is usually slow, so we have a fast path where we try to deduce the correct match boundary after an initial match (before running capture groups). The problem is that doing this is rather tricky because it's hard to know, in general, whether the `^` or the `\\W` matched.\r\n\r\nThis still doesn't seem quite right overall, but we at least fix one more case.\r\n\r\nFixes #2574","title":"regex: fix fast path for -w/--word-regexp flag","FAIL_TO_PASS":["regression::r2574"],"PASS_TO_PASS":["regression::r1159_invalid_flag","regression::r105_part1","regression::r1163","regression::r1064","regression::r1098","regression::r1130","regression::r105_part2","regression::r1174","regression::r1176_line_regex","regression::r1176_literal_file","regression::r1173","regression::r1223_no_dir_check_for_default_path","regression::r1164","regression::r128","regression::r1311_multi_line_term_replace","regression::r1259_drop_last_byte_nonl","regression::r127","regression::r131","regression::r1401_look_ahead_only_matching_1","regression::r1401_look_ahead_only_matching_2","regression::r1412_look_behind_no_replacement","regression::r1334_crazy_literals","regression::r1380","regression::r1319","regression::r1389_bad_symlinks_no_biscuit","regression::r1573","regression::r137","regression::r1446_respect_excludes_in_worktree","regression::r1559","regression::r1537","regression::r1739_replacement_lineterm_match","regression::r16","regression::r156","regression::r1638","regression::r1765","regression::r1866","regression::r199","regression::r1203_reverse_suffix_literal","regression::r206","regression::r184","regression::r210","regression::r1159_exit_status","regression::r2236","regression::r2198","regression::r228","regression::r229","regression::r2095","regression::r1878","regression::r256","regression::r256_j1","regression::r251","regression::r2208","regression::r1868_context_passthru_override","regression::r25","regression::r270","regression::r391","regression::r279","regression::r30","regression::r405","regression::r1891","regression::r451_only_matching","regression::r451_only_matching_as_in_issue","regression::r428_color_context_path","regression::r483_matching_no_stdout","regression::r483_non_matching_exit_code","regression::r428_unrecognized_style","regression::r493","regression::r2480","regression::r49","regression::r50","regression::r599","regression::r64","regression::r553_flag","regression::r693_context_in_contextless_mode","regression::r65","regression::r568_leading_hyphen_option_args","regression::r67","regression::r900","regression::r807","regression::r87","regression::r99","regression::r90","regression::r553_switch","regression::r506_word_not_parenthesized","regression::r93"]}
